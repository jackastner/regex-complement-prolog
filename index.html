<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="John Kastner" />
  <title>Complementing Regular Expressions</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complementing Regular Expressions</h1>
<p class="author">John Kastner</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>In this program we attempt to complete the <a href="https://codegolf.stackexchange.com/questions/161108/complement-of-a-regex">“Complement of a Regex”</a> question posted to Code Golf &amp; Coding Challenges using Prolog. Briefly, the challenge is to take as input a simplified postfix regular expression (regex) dialect defined over the alphabet <span class="math inline">{0, 1}</span> and output a new regex that matches exactly those strings that were not matched by the original regex.</p>
<p>This file is and annotated version of the code intended to be processed by <a href="https://pandoc.org/">Pandoc</a> to obtain a nicely formatted document. It can also be processed by Pandoc through the <a href="https://github.com/ehildenb/pandoc-tangle">pandoc-tangle</a> filter to obtain executable source code. The unannotated source is also <a href="https://github.com/jackastner/regex-complement-prolog/blob/gh-pages/regex.pl">available on github</a>.</p>
<p>The approach we will use is as follows:</p>
<ol type="1">
<li>Parse the string representation of regex into an abstract syntax tree.</li>
<li>Convert the abstract syntax tree of the regex into a non-deterministic finite automaton (NFA).</li>
<li>Convert the NFA into a deterministic finite automaton (DFA).</li>
<li>Complement the DFA. This is accomplished by complementing the set of accepting states.</li>
<li>Convert the resulting DFA into a regular expression.</li>
</ol>
<p>This is demonstrated by the following predicate which takes a regular expression encoded as a string and generates its complement.</p>
<div class="sourceCode" id="cb1" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb1-1"><a href="#cb1-1"></a>complement_regex_string(<span class="dt">Regex_String</span><span class="kw">,</span> <span class="dt">Regex_Comp_String</span>) <span class="kw">:-</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  string_codes(<span class="dt">Regex_String</span><span class="kw">,</span> <span class="dt">Regex_Codes</span>)<span class="kw">,</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  parse_regex(<span class="dt">Regex_Codes</span><span class="kw">,</span> <span class="dt">Regex</span>)<span class="kw">,</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  regex_nfa(<span class="dt">Regex</span><span class="kw">,</span> <span class="dt">NFA</span>)<span class="kw">,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  nfa_dfa(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">DFA</span>)<span class="kw">,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  dfa_complement(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">DFA_Comp</span>)<span class="kw">,</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  dfa_regex(<span class="dt">DFA_Comp</span><span class="kw">,</span> <span class="dt">Regex_Comp</span>)<span class="kw">,</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  show_regex(<span class="dt">Regex_Comp</span><span class="kw">,</span> <span class="dt">Regex_Comp_Codes</span>)<span class="kw">,</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  string_codes(<span class="dt">Regex_Comp_String</span><span class="kw">,</span> <span class="dt">Regex_Comp_Codes</span>)<span class="kw">.</span></span></code></pre></div>
<p>The predicate can be invoked from the SWI-Prolog top level environment. Testing it on simple input yields correct if rather long output. I have not extensively validated the conversion on larger inputs.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">?-</span> complement_regex_string(<span class="ot">&quot;0&quot;</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">S</span> <span class="kw">=</span> <span class="ot">&quot;010|10</span><span class="er">_</span><span class="ot">||*10</span><span class="er">_</span><span class="ot">||;;10||;110</span><span class="er">_</span><span class="ot">||*10</span><span class="er">_</span><span class="ot">||;;1||</span><span class="er">_</span><span class="ot">!||&quot;</span> <span class="kw">.</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="fu">?-</span> complement_regex_string(<span class="ot">&quot;1&quot;</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">S</span> <span class="kw">=</span> <span class="ot">&quot;110|10</span><span class="er">_</span><span class="ot">||*10</span><span class="er">_</span><span class="ot">||;;10||;010</span><span class="er">_</span><span class="ot">||*10</span><span class="er">_</span><span class="ot">||;;0||</span><span class="er">_</span><span class="ot">!||&quot;</span> <span class="kw">.</span></span></code></pre></div>
<h1 id="parsing-regular-expressions">Parsing Regular Expressions</h1>
<p>We first need to construct an abstract syntax tree for a simplified regex. This is easy using Prologs built in syntax for DCGs. We define a predicate <code>parse_regex//2</code> where the first argument is the current stack of encountered regex and the second is the final regex constructed by the parse.</p>
<p>The simplest cases are the single character regex . If we see <code>0</code> of <code>1</code>, we construct a regex for a character literal and push it onto the stack. Matching <code>_</code> for the empty regex and <code>!</code> for the null regex is handled similarly.</p>
<div class="sourceCode" id="cb3" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb3-1"><a href="#cb3-1"></a>parse_regex(<span class="dt">RS</span><span class="kw">,</span> <span class="dt">R</span>) <span class="kw">--&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">&quot;0&quot;</span><span class="kw">,</span> parse_regex([regex_char(<span class="dv">0</span>)<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="ot">&quot;1&quot;</span><span class="kw">,</span> parse_regex([regex_char(<span class="dv">1</span>)<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="ot">&quot;</span><span class="er">_</span><span class="ot">&quot;</span><span class="kw">,</span> parse_regex([regex_empty<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="ot">&quot;!&quot;</span><span class="kw">,</span> parse_regex([regex_null<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">.</span></span></code></pre></div>
<p>Handling concatenation and union regex is more complicated because they are constructed from previously encountered regex . In both cases, there must be at least two regex on the stack. If they are present and <code>|</code> is encountered, the regex are popped and their union is push back onto the stack before continuing the parse. If <code>;</code> is encountered, their concatenation is pushed instead.</p>
<div class="sourceCode" id="cb4" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb4-1"><a href="#cb4-1"></a>parse_regex([<span class="dt">R0</span>,<span class="dt">R1</span><span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">--&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">&quot;|&quot;</span><span class="kw">,</span> parse_regex([regex_union(<span class="dt">R1</span><span class="kw">,</span> <span class="dt">R0</span>)<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="ot">&quot;;&quot;</span><span class="kw">,</span> parse_regex([regex_concat(<span class="dt">R1</span><span class="kw">,</span> <span class="dt">R0</span>)<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">.</span></span></code></pre></div>
<p>Parsing the <code>+</code> quantifier a very similar but, it only requires one regular expression on the stack. The regex pushed onto the stack in this case is more interesting because we do not include <code>+</code> as a regex combinator. It is instead defined as the concatenation of a regex with the Kleene closure for the same expression (i.e. <code>RR*</code>).</p>
<div class="sourceCode" id="cb5" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb5-1"><a href="#cb5-1"></a>parse_regex([<span class="dt">R0</span><span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">--&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ot">&quot;+&quot;</span><span class="kw">,</span> parse_regex([regex_concat(<span class="dt">R0</span><span class="kw">,</span> regex_kleene(<span class="dt">R0</span>))<span class="fu">|</span><span class="dt">RS</span>]<span class="kw">,</span> <span class="dt">R</span>)<span class="kw">.</span></span></code></pre></div>
<p>The final step in parsing is handling the end of the input string. When there are no more characters available, we examine the stack to determine if there if it contains a single regex . When this is the case, that expression the final parsed expression. If there is more than one regular expression on the stack, then the input string was not a well formed postfix regex , so the predicate fails.</p>
<div class="sourceCode" id="cb6" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb6-1"><a href="#cb6-1"></a>parse_regex([<span class="dt">R</span>]<span class="kw">,</span><span class="dt">R</span>) <span class="kw">--&gt;</span> <span class="kw">\+</span> [<span class="dt">_</span>]<span class="kw">.</span></span></code></pre></div>
<p>With the DCG defined, we can define and additional predicate <code>parse_regex/2</code> that invokes the DCG predicate with an initially empty stack and requiring that the entire input string is consumed while parsing.</p>
<div class="sourceCode" id="cb7" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb7-1"><a href="#cb7-1"></a>parse_regex(<span class="dt">S</span><span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  parse_regex([]<span class="kw">,</span> <span class="dt">R</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> [])<span class="kw">.</span></span></code></pre></div>
<h1 id="converting-regular-expressions-to-nfa">Converting Regular Expressions to NFA</h1>
<p>We now need to transform the abstract syntax tree of regular expression into a NFA which can be done using <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson’s construction</a>. While we do not use the exact same construction, the intuition is identical.</p>
<p>Before implementing the construction, we need a way to obtain unique identifiers for states in the NFA. We can do this by assigning the first state to be <code>0</code> and incrementing the identifier for each subsequent state. In an imperative language, the current value of the identifier might be tracked in a global variable or local variable outside the body of a loop. A global variable could be used in Prolog, but it is not desirable. Instead, we can opt for an approach similar what would be used in the functional paradigm: a function takes as part of its input the current identifier value, and returns with its output and additional value for the next available identifier. The problem with this approach is that we explicitly thread some state though the program. To avoid this overhead, something similar to the state monad in Haskell can be used.</p>
<p>In Prolog, the state monad is approximated using a DCG. The current identifier value is tracked as the first and only element of the list being processed. When an identifier is needed, the value is removed from the list, incremented, and added back onto the list. The original value can then be used as an identifier. The DCG predicate <code>fresh//1</code> handles the list updates and unifies its argument with the available identifier value.</p>
<div class="sourceCode" id="cb8" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1"></a>fresh(<span class="dt">S</span>)<span class="kw">,</span> [<span class="dt">T</span>] <span class="kw">--&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  [<span class="dt">S</span>]<span class="kw">,</span> <span class="kw">{</span><span class="dt">T</span> <span class="dt">is</span> <span class="dt">S</span> <span class="dt">+</span> <span class="dv">1</span><span class="kw">}.</span></span></code></pre></div>
<p>To implement the construction, we also need some data structure to represent an NFA. Recall that an NFA is <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton#Formal_definition">defined by a 5-tuple</a> <span class="math inline">(<em>Q</em>, <em>Σ</em>, <em>Δ</em>, <em>q</em><sub>0</sub>, <em>f</em>)</span>: a set of states, an alphabet, a transition function, and initial state, and a final state. We are working with a fixed alphabet (<span class="math inline">{0, 1}</span>), so we will ignore <span class="math inline"><em>Σ</em></span> and encode the remaining four elements in a dictionary defined as follows. Note that the transition function is defined by a set of triples rather than a function.</p>
<div class="sourceCode" id="cb9" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb9-1"><a href="#cb9-1"></a>is_nfa(nfa<span class="kw">{</span>states<span class="fu">:</span> <span class="dt">_</span><span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">_</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">_</span><span class="kw">,</span> delta<span class="fu">:</span> <span class="dt">DS</span><span class="kw">}</span>) <span class="kw">:-</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  forall(member(<span class="dt">D</span><span class="kw">,</span> <span class="dt">DS</span>)<span class="kw">,</span> is_delta(<span class="dt">D</span>))<span class="kw">.</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>is_delta(<span class="dt">__From</span><span class="fu">-</span><span class="dt">__Char</span><span class="fu">-</span><span class="dt">__To</span>)<span class="kw">.</span></span></code></pre></div>
<p>The two simplest regular expressions are the empty regular expression and the null regular expression. NFA constructed for the empty regular expression is an NFA with exactly one state that is both the initial and the final state (no transitions are required). An identifier for this state is obtained by unifying <code>A</code> in <code>fresh//1</code>.</p>
<div class="sourceCode" id="cb10" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1"></a>regex_nfa(regex_empty<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  fresh(<span class="dt">A</span>)<span class="kw">,</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">{</span><span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> [<span class="dt">A</span>]<span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">A</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">A</span><span class="kw">,</span> delta<span class="fu">:</span> []<span class="kw">}}.</span></span></code></pre></div>
<p>The null regex does not accept any strings, so there should be not way to move from the initial state to the final state. This is encoded by obtaining two state identifiers for the initial and final state while not generating any transitions between them.</p>
<div class="sourceCode" id="cb11" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb11-1"><a href="#cb11-1"></a>regex_nfa(regex_null<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  fresh(<span class="dt">A</span>)<span class="kw">,</span> fresh(<span class="dt">B</span>)<span class="kw">,</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">{</span><span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> [<span class="dt">A</span>, <span class="dt">B</span>]<span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">A</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">B</span><span class="kw">,</span> delta<span class="fu">:</span> []<span class="kw">}}.</span></span></code></pre></div>
<p>A character literal regex follows very directly from this. Instead of there being no path from <code>A</code> to <code>B</code>, there should be single path that requires transitioning on the character in question.</p>
<div class="sourceCode" id="cb12" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb12-1"><a href="#cb12-1"></a>regex_nfa(regex_char(<span class="dt">C</span>)<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  fresh(<span class="dt">A</span>)<span class="kw">,</span> fresh(<span class="dt">B</span>)<span class="kw">,</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">{</span><span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> [<span class="dt">A</span>, <span class="dt">B</span>]<span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">A</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">B</span><span class="kw">,</span> delta<span class="fu">:</span> [<span class="dt">A</span><span class="fu">-</span><span class="dt">C</span><span class="fu">-</span><span class="dt">B</span>]<span class="kw">}}.</span></span></code></pre></div>
<p>The following three cases are somewhat more complicate since they require integrating one or more existing NFA into a new NFA. In all cases we first obtain NFA for the sub-expressions for the input regular expression with recursive calls to <code>regex_nfa//2</code>.</p>
<p>To construct the NFA for a union of two regular expression, we need to construct the union of the sub-expressions NFA. To do this, we first obtain two fresh states for the resulting NFA: one for the initial state (<code>I</code>) and one for the final state (<code>F</code>). Transitions are then required between the new states and the existing NFA. From the initial state, there must be a transitions on the empty string (<span class="math inline"><em>ε</em></span>, written here as <code>e</code>) to the initial state of both NFA. From the final state of both NFA, there must be a transitions on <span class="math inline"><em>ε</em></span> to the new final state. The states and transitions for the final NFA are the union of these new states and transitions with all existing states and transitions from both NFA.</p>
<div class="sourceCode" id="cb13" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb13-1"><a href="#cb13-1"></a>regex_nfa(regex_union(<span class="dt">L</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  fresh(<span class="dt">I</span>)<span class="kw">,</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  regex_nfa(<span class="dt">L</span><span class="kw">,</span> <span class="dt">NFA_L</span>)<span class="kw">,</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  regex_nfa(<span class="dt">R</span><span class="kw">,</span> <span class="dt">NFA_R</span>)<span class="kw">,</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>  fresh(<span class="dt">F</span>)<span class="kw">,</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="kw">{</span>append([<span class="dt">NFA_L</span>.states, <span class="dt">NFA_R</span>.states, [<span class="dt">I</span>, <span class="dt">F</span>]]<span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>   <span class="dt">Delta_I</span> <span class="kw">=</span> [<span class="dt">I</span><span class="fu">-</span>e<span class="fu">-</span><span class="dt">NFA_L</span>.initial, <span class="dt">I</span><span class="fu">-</span>e<span class="fu">-</span><span class="dt">NFA_R</span>.initial]<span class="kw">,</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>   <span class="dt">Delta_F</span> <span class="kw">=</span> [<span class="dt">NFA_L</span>.final<span class="fu">-</span>e<span class="fu">-</span><span class="dt">F</span>, <span class="dt">NFA_R</span>.final<span class="fu">-</span>e<span class="fu">-</span><span class="dt">F</span>]<span class="kw">,</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>   append([<span class="dt">Delta_F</span>, <span class="dt">Delta_I</span>, <span class="dt">NFA_L</span>.delta, <span class="dt">NFA_R</span>.delta]<span class="kw">,</span> <span class="dt">Delta</span>)<span class="kw">,</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>   <span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> <span class="dt">States</span><span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">I</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">F</span><span class="kw">,</span> delta<span class="fu">:</span> <span class="dt">Delta</span><span class="kw">}}.</span></span></code></pre></div>
<p>For a concatenation, we do not need any new states. The new initial state is the initial state of the left NFA while the new final states is the final state of the right NFA. A transitions on <span class="math inline"><em>ε</em></span> is then required between the final state of the left NFA and the initial state of the right NFA.</p>
<div class="sourceCode" id="cb14" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1"></a>regex_nfa(regex_concat(<span class="dt">L</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>  regex_nfa(<span class="dt">L</span><span class="kw">,</span> <span class="dt">NFA_L</span>)<span class="kw">,</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>  regex_nfa(<span class="dt">R</span><span class="kw">,</span> <span class="dt">NFA_R</span>)<span class="kw">,</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>  <span class="kw">{</span>append(<span class="dt">NFA_L</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">NFA_R</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>   <span class="dt">Delta_M</span> <span class="kw">=</span> [<span class="dt">NFA_L</span>.final<span class="fu">-</span>e<span class="fu">-</span><span class="dt">NFA_R</span>.initial]<span class="kw">,</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>   append([<span class="dt">Delta_M</span>, <span class="dt">NFA_L</span>.delta, <span class="dt">NFA_R</span>.delta]<span class="kw">,</span> <span class="dt">Delta</span>)<span class="kw">,</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>   <span class="dt">I</span> <span class="kw">=</span> <span class="dt">NFA_L</span>.initial<span class="kw">,</span> <span class="dt">F</span> <span class="kw">=</span> <span class="dt">NFA_R</span>.final<span class="kw">,</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>   <span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> <span class="dt">States</span><span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">I</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">F</span><span class="kw">,</span> delta<span class="fu">:</span> <span class="dt">Delta</span><span class="kw">}}.</span></span></code></pre></div>
<p>As in the previews cases, constructing the NFA for a Kleene closure requires first constructing the NFA for a sub-expression. Since a Kleene closure can satisfy the regex once, the initial and final states of this NFA should not be changed. We will add transitions so that the expression can be satisfied more than one time or zero times. Satisfying the expression zero times is the same as skipping over the recursively constructed NFA entirely. We encode this possibility by adding a transition on <span class="math inline"><em>ε</em></span> from the initial state to the final state. To satisfy the expression more than once, we should be able to return to the state initial state after reaching the final state. This is encoded by an <span class="math inline"><em>ε</em></span> transition from the final state to the initial state.</p>
<div class="sourceCode" id="cb15" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb15-1"><a href="#cb15-1"></a>regex_nfa(regex_kleene(<span class="dt">K</span>)<span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">--&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  regex_nfa(<span class="dt">K</span><span class="kw">,</span> <span class="dt">NFA_K</span>)<span class="kw">,</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="kw">{</span><span class="dt">Delta_K</span> <span class="kw">=</span> [<span class="dt">NFA_K</span>.initial<span class="fu">-</span>e<span class="fu">-</span><span class="dt">NFA_K</span>.final, <span class="dt">NFA_K</span>.final<span class="fu">-</span>e<span class="fu">-</span><span class="dt">NFA_K</span>.initial]<span class="kw">,</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>   append(<span class="dt">Delta_K</span><span class="kw">,</span> <span class="dt">NFA_K</span><span class="al">.</span>delta<span class="kw">,</span> <span class="dt">Delta</span>)<span class="kw">,</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>   <span class="dt">I</span> <span class="kw">=</span> <span class="dt">NFA_K</span>.initial<span class="kw">,</span> <span class="dt">F</span> <span class="kw">=</span> <span class="dt">NFA_K</span>.final<span class="kw">,</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>   <span class="dt">NFA</span> <span class="kw">=</span> nfa<span class="kw">{</span>states<span class="fu">:</span> <span class="dt">NFA_K</span>.states<span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">I</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">F</span><span class="kw">,</span> delta<span class="fu">:</span> <span class="dt">Delta</span><span class="kw">}}.</span></span></code></pre></div>
<p>Since invoking the DCG predicate we have defined requires providing two implicit parameters, it is convenient to define an additional predicate that can be invoked directly.</p>
<div class="sourceCode" id="cb16" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb16-1"><a href="#cb16-1"></a>regex_nfa(<span class="dt">Regex</span><span class="kw">,</span> <span class="dt">NFA</span>) <span class="kw">:-</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>  regex_nfa(<span class="dt">Regex</span><span class="kw">,</span> <span class="dt">NFA</span><span class="kw">,</span> [<span class="dv">0</span>]<span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span></code></pre></div>
<h1 id="converting-nfa-to-dfa">Converting NFA to DFA</h1>
<p>We use the usual <a href="https://en.wikipedia.org/wiki/Powerset_construction">powerset construction</a> to convert NFA to DFA. The exact implementation is modified to only construct reachable states. The premise of the powerset construction is that the set of states in the constructed DFA is powerset of the states in the NFA. In other words, each state within the DFA is some subset of the states of the NFA.</p>
<p>Using this new set of states, we also need to determine what state is the initial states, what states are final states are final states, and what transitions exists between the states. The new initial state is derived from the original initial state by taking the set of all states reachable on <span class="math inline"><em>ε</em></span> transitions from the initial states. Finding these reachable states for an arbitrary starting state is called the <span class="math inline"><em>ε</em></span> closure of the state. From this initial state, we can find the set of states reachable after any number of transitions. This is the set of states in the constructed DFA. The set of final states contains every state in the set of reachable states that contains the final state of the original NFA. Finally, we need the transition function between the states in the set of states.</p>
<div class="sourceCode" id="cb17" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb17-1"><a href="#cb17-1"></a>nfa_dfa(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">DFA</span>) <span class="kw">:-</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="dt">DFA</span> <span class="kw">=</span> dfa<span class="kw">{</span>states<span class="fu">:</span> <span class="dt">States</span><span class="kw">,</span> initial<span class="fu">:</span> <span class="dt">I</span><span class="kw">,</span> final<span class="fu">:</span> <span class="dt">F</span><span class="kw">,</span> delta<span class="fu">:</span> <span class="dt">Delta</span><span class="kw">},</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  setof(<span class="dt">S</span><span class="kw">,</span> epsilon_close(<span class="dt">NFA</span><span class="al">.</span>delta<span class="kw">,</span> <span class="dt">NFA</span><span class="al">.</span>initial<span class="kw">,</span> <span class="dt">S</span>)<span class="kw">,</span> <span class="dt">I</span>)<span class="kw">,</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>  new_states([<span class="dt">I</span>]<span class="kw">,</span> <span class="dt">NFA</span><span class="al">.</span>delta<span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>  findall(<span class="dt">S</span><span class="kw">,</span> (member(<span class="dt">S</span><span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span> member(<span class="dt">NFA</span><span class="al">.</span>final<span class="kw">,</span> <span class="dt">S</span>))<span class="kw">,</span> <span class="dt">F</span>)<span class="kw">,</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>  bagof(<span class="dt">D</span><span class="kw">,</span> <span class="dt">S</span><span class="fu">^</span>(member(<span class="dt">S</span><span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span> new_transition(<span class="dt">S</span><span class="kw">,</span> <span class="dt">NFA</span><span class="al">.</span>delta<span class="kw">,</span> <span class="dt">D</span>))<span class="kw">,</span> <span class="dt">Delta</span>)<span class="kw">.</span></span></code></pre></div>
<p>An important step in the above procedure was finding the set of all states reachable by any number of <span class="math inline"><em>ε</em></span> transitions from a given set of states (states in this context refers to NFA states, so a set of these states is equivalent to a singular DFA state). This is called an <span class="math inline"><em>ε</em></span>-closure.</p>
<p>There are two relevant cases when computing the <span class="math inline"><em>ε</em></span>-closure. First, the closure of a single DFA state contains itself since it can be reached after zero <span class="math inline"><em>ε</em></span> transitions. Second, the <span class="math inline"><em>ε</em></span>-closure of every state reachable after a single epsilon transition is a subset of the closure of the original state. Each of these states is in its own <span class="math inline"><em>ε</em></span>-closure by the first case, so they are in the final closure.</p>
<p>Two special considerations are made when implementing this function. After a transition is included in the closure, it is removed from consideration in future recursive calls. Additionally, any <span class="math inline"><em>ε</em></span> transitions incident to the state included in the closure are removed. These rules ensure that no state is visited more than once and that the closure procedure terminates.</p>
<p>Note that <code>epsilon_close/3</code> is written as a predicate to test if a state is in the epsilon closure of another state. When the predicate is invoked, it wrapped in <code>setof/3</code> to collect all states in the closure into a single list.</p>
<div class="sourceCode" id="cb18" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb18-1"><a href="#cb18-1"></a>epsilon_close(<span class="dt">_</span><span class="kw">,</span><span class="dt">S</span><span class="kw">,</span><span class="dt">S</span>)<span class="kw">.</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>epsilon_close(<span class="dt">Delta</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">E</span>) <span class="kw">:-</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>  select(<span class="dt">S</span><span class="fu">-</span>e<span class="fu">-</span><span class="dt">T</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">Delta2</span>)<span class="kw">,</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>  findall(<span class="dt">E</span><span class="kw">,</span>(member(<span class="dt">E</span><span class="kw">,</span><span class="dt">Delta2</span>)<span class="kw">,</span> <span class="dt">E</span><span class="kw">=</span><span class="dt">_</span><span class="fu">-</span>e<span class="fu">-</span><span class="dt">S</span>)<span class="kw">,</span> <span class="dt">Del</span>)<span class="kw">,</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  subtract(<span class="dt">Delta2</span><span class="kw">,</span> <span class="dt">Del</span><span class="kw">,</span> <span class="dt">Delta3</span>)<span class="kw">,</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>  epsilon_close(<span class="dt">Delta3</span><span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">E</span>)<span class="kw">.</span></span></code></pre></div>
<p>To compute the transitions in the final DFA, we start with a state from the DFA (a set of NFA states) and the set of transitions in the original DFA. We then compute the DFA transitions out of that state using the available NFA transitions. Such transitions are constructed by selecting a single NFA state from the DFA state and a transition out of this state. The <span class="math inline"><em>ε</em></span>-closure of the destination of this transitions is the destination of the constructed transition while the original DFA state is the source.</p>
<div class="sourceCode" id="cb19" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb19-1"><a href="#cb19-1"></a>new_transition(<span class="dt">States</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">States</span><span class="fu">-</span><span class="dt">D</span><span class="fu">-</span><span class="dt">TS</span>) <span class="kw">:-</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>  member(<span class="dt">D</span><span class="kw">,</span> [<span class="dv">0</span>, <span class="dv">1</span>])<span class="kw">,</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="co">% </span><span class="al">TODO</span><span class="co">: this doesn&#39;t handle multiple transistions on the same character out</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>  <span class="co">% of a single state. Need to add a union somewhere.</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>  (setof(<span class="dt">S</span><span class="kw">,</span> <span class="dt">T</span><span class="fu">^</span><span class="dt">F</span><span class="fu">^</span>(</span>
<span id="cb19-6"><a href="#cb19-6"></a>    member(<span class="dt">F</span><span class="kw">,</span><span class="dt">States</span>)<span class="kw">,</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>    member(<span class="dt">F</span><span class="fu">-</span><span class="dt">D</span><span class="fu">-</span><span class="dt">T</span><span class="kw">,</span> <span class="dt">Delta</span>)<span class="kw">,</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>    epsilon_close(<span class="dt">Delta</span><span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">S</span>)</span>
<span id="cb19-9"><a href="#cb19-9"></a>  )<span class="kw">,</span> <span class="dt">TS</span>) <span class="kw">-&gt;</span> <span class="kw">true</span> <span class="kw">;</span> <span class="dt">TS</span><span class="kw">=</span>[])<span class="kw">.</span></span></code></pre></div>
<p>The set of states in the final DFA could be computed by taking the powerset of the NFA states; however, this results in many states being included that are not reachable after any number of transitions from the initial state of the DFA. Instead, the set of states is found by starting with only the initial state and progressively adding to the set of known states by adding to the set any states that can be transitioned to from any state within the set. This expansions is repeated until a fixed point is reached (i.e. no new states are discovered).</p>
<div class="sourceCode" id="cb20" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb20-1"><a href="#cb20-1"></a>new_states(<span class="dt">States</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">AllStates</span>) <span class="kw">:-</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  setof(<span class="dt">E</span><span class="kw">,</span> <span class="dt">S</span><span class="fu">^</span>(member(<span class="dt">S</span><span class="kw">,</span> <span class="dt">States</span>)<span class="kw">,</span> new_state(<span class="dt">S</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">E</span>))<span class="kw">,</span> <span class="dt">Expanded</span>)<span class="kw">,</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>  subtract(<span class="dt">Expanded</span><span class="kw">,</span> <span class="dt">States</span><span class="kw">,</span> <span class="dt">New</span>)<span class="kw">,</span> (</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="dt">New</span> <span class="kw">=</span> []<span class="kw">,</span> <span class="dt">AllStates</span> <span class="kw">=</span> <span class="dt">States</span><span class="kw">;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="dt">New</span> <span class="kw">=</span> [<span class="dt">_</span><span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span> union(<span class="dt">States</span><span class="kw">,</span> <span class="dt">New</span><span class="kw">,</span> <span class="dt">Union</span>)<span class="kw">,</span> new_states(<span class="dt">Union</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">AllStates</span>)</span>
<span id="cb20-6"><a href="#cb20-6"></a>  )<span class="kw">.</span></span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a>new_state(<span class="dt">States</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">New</span>) <span class="kw">:-</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>  new_transition(<span class="dt">States</span><span class="kw">,</span> <span class="dt">Delta</span><span class="kw">,</span> <span class="dt">_</span><span class="fu">-</span><span class="dt">_</span><span class="fu">-</span><span class="dt">New</span>)<span class="kw">.</span></span></code></pre></div>
<h1 id="complementing-dfa">Complementing DFA</h1>
<p>Moving from the string representation of a regex to a DFA took a quite a bit of working when all we set out to do was computing its complement. At this point taking the complement is fortunately easy. We simply replace the set of final states with its complement.</p>
<div class="sourceCode" id="cb21" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb21-1"><a href="#cb21-1"></a>dfa_complement(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Complement</span>) <span class="kw">:-</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>  <span class="dt">Complement</span> <span class="kw">=</span> dfa<span class="kw">{</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    states<span class="fu">:</span> <span class="dt">DFA</span>.states<span class="kw">,</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>    initial<span class="fu">:</span> <span class="dt">DFA</span>.initial<span class="kw">,</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>    delta<span class="fu">:</span> <span class="dt">DFA</span>.delta<span class="kw">,</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    final<span class="fu">:</span> <span class="dt">Final</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>  <span class="kw">},</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  subtract(<span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>final<span class="kw">,</span> <span class="dt">Final</span>)<span class="kw">.</span></span></code></pre></div>
<h1 id="converting-dfa-to-regular-expressions">Converting DFA to Regular Expressions</h1>
<p>We convert a complemented DFA into a regular expression using <a href="https://en.wikipedia.org/wiki/Kleene%27s_algorithm">Kleene’s Algorithm</a> which is briefly given by the following recursive relation which is implemented by <code>dfa_regex/4</code>.</p>
<p><br /><span class="math display"><em>R</em><sub><em>i</em><em>j</em></sub><sup> − 1</sup> = {<em>ε</em> ∣ <em>i</em> = <em>j</em>} ∪ ⋃{<em>σ</em> ∣ <em>q</em><sub><em>j</em></sub> ∈ <em>δ</em>(<em>q</em><sub><em>i</em></sub>, <em>σ</em>) ∧ <em>σ</em> ∈ <em>Σ</em>}</span><br /> <br /><span class="math display"><em>R</em><sub><em>i</em><em>j</em></sub><sup><em>k</em></sup> = <em>R</em><sub><em>i</em><em>k</em></sub><sup><em>k</em> − 1</sup>(<em>R</em><sub><em>k</em><em>k</em></sub><sup><em>k</em> − 1</sup>)<sup>*</sup><em>R</em><sub><em>k</em><em>j</em></sub><sup><em>k</em> − 1</sup> ∪ <em>R</em><sub><em>i</em><em>j</em></sub><sup><em>k</em> − 1</sup></span><br /></p>
<div class="sourceCode" id="cb22" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">:-</span> table dfa_regex<span class="fu">/</span><span class="dv">5</span><span class="kw">.</span></span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a>dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dv">-1</span><span class="kw">,</span> <span class="dt">I</span><span class="kw">,</span> <span class="dt">J</span><span class="kw">,</span> <span class="dt">Simpl_RE</span>) <span class="kw">:-</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>  nth0(<span class="dt">I</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">QI</span>)<span class="kw">,</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  nth0(<span class="dt">J</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">QJ</span>)<span class="kw">,</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>  setof(<span class="dt">R</span><span class="kw">,</span> <span class="dt">C</span><span class="fu">^</span>(</span>
<span id="cb22-7"><a href="#cb22-7"></a>    member(<span class="dt">C</span><span class="kw">,</span> [<span class="dv">0</span>, <span class="dv">1</span>])<span class="kw">,</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>    (member(<span class="dt">QI</span><span class="fu">-</span><span class="dt">C</span><span class="fu">-</span><span class="dt">QJ</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>delta) <span class="kw">-&gt;</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>      <span class="dt">R</span> <span class="kw">=</span> regex_char(<span class="dt">C</span>)<span class="kw">;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>      <span class="dt">R</span> <span class="kw">=</span> regex_null)</span>
<span id="cb22-11"><a href="#cb22-11"></a>  )<span class="kw">,</span> <span class="dt">RES</span>)<span class="kw">,</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>  (<span class="dt">I</span> <span class="kw">=</span> <span class="dt">J</span> <span class="kw">-&gt;</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>    fold_union([regex_empty<span class="fu">|</span><span class="dt">RES</span>]<span class="kw">,</span> <span class="dt">RE</span>)<span class="kw">;</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>    fold_union(<span class="dt">RES</span><span class="kw">,</span> <span class="dt">RE</span>))<span class="kw">,</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>  simpl_regex(<span class="dt">RE</span><span class="kw">,</span><span class="dt">Simpl_RE</span>)<span class="kw">.</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a>dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">I</span><span class="kw">,</span> <span class="dt">J</span><span class="kw">,</span> <span class="dt">RE</span>) <span class="kw">:-</span></span>
<span id="cb22-18"><a href="#cb22-18"></a>  <span class="dt">K</span> <span class="dt">&gt;</span> <span class="dv">-1</span><span class="kw">,</span></span>
<span id="cb22-19"><a href="#cb22-19"></a>  <span class="dt">Pred_K</span> <span class="dt">is</span> <span class="dt">K</span> <span class="dt">-</span> <span class="dv">1</span><span class="kw">,</span></span>
<span id="cb22-20"><a href="#cb22-20"></a>  dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Pred_K</span><span class="kw">,</span> <span class="dt">I</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">R_IK</span>)<span class="kw">,</span></span>
<span id="cb22-21"><a href="#cb22-21"></a>  dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Pred_K</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">R_KK</span>)<span class="kw">,</span></span>
<span id="cb22-22"><a href="#cb22-22"></a>  dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Pred_K</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">J</span><span class="kw">,</span> <span class="dt">R_KJ</span>)<span class="kw">,</span></span>
<span id="cb22-23"><a href="#cb22-23"></a>  dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Pred_K</span><span class="kw">,</span> <span class="dt">I</span><span class="kw">,</span> <span class="dt">J</span><span class="kw">,</span> <span class="dt">R_IJ</span>)<span class="kw">,</span></span>
<span id="cb22-24"><a href="#cb22-24"></a>  simpl_regex(regex_union(regex_concat(<span class="dt">R_IK</span><span class="kw">,</span> regex_concat(regex_kleene(<span class="dt">R_KK</span>)<span class="kw">,</span> <span class="dt">R_KJ</span>))<span class="kw">,</span> <span class="dt">R_IJ</span>)<span class="kw">,</span> <span class="dt">RE</span>)<span class="kw">.</span></span></code></pre></div>
<p>The above predicate alone is not enough to convert an NFA to a DFA. The predicate find the regex for the language of strings recognized by the DFA starting in state <span class="math inline"><em>i</em></span>, ending in state <span class="math inline"><em>j</em></span> and passing through states index no higher than <span class="math inline"><em>k</em></span>. A regex for a DFA with a single final state could be found by <span class="math inline"><em>R</em><sub><em>q</em><sub>0</sub><em>q</em><sub><em>f</em></sub></sub><sup> ∣ <em>Q</em>∣</sup></span>. Since there can be arbitrarily many final states, this must be computed for each <span class="math inline"><em>q</em><sub><em>f</em></sub> ∈ <em>f</em></span>. The final regular expression is the union of all computed regular expressions.</p>
<p><br /><span class="math display"><em>R</em> = ⋃{<em>R</em><sub><em>q</em><sub><em>o</em></sub><em>q</em><sub><em>f</em></sub></sub><sup> ∣ <em>Q</em>∣</sup>|<em>q</em><sub><em>f</em></sub> ∈ <em>f</em>}</span><br /></p>
<div class="sourceCode" id="cb23" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb23-1"><a href="#cb23-1"></a>dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">Regex</span>) <span class="kw">:-</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>  length(<span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">,</span> <span class="dt">K</span> <span class="dt">is</span> <span class="dt">L</span> <span class="dt">-</span> <span class="dv">1</span><span class="kw">,</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>  nth0(<span class="dt">I</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>initial)<span class="kw">,</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>  findall(<span class="dt">Regex_F</span><span class="kw">,</span> (</span>
<span id="cb23-5"><a href="#cb23-5"></a>    member(<span class="dt">Final</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>final)<span class="kw">,</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>    nth0(<span class="dt">J</span><span class="kw">,</span> <span class="dt">DFA</span><span class="al">.</span>states<span class="kw">,</span> <span class="dt">Final</span>)<span class="kw">,</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    dfa_regex(<span class="dt">DFA</span><span class="kw">,</span> <span class="dt">K</span><span class="kw">,</span> <span class="dt">I</span><span class="kw">,</span> <span class="dt">J</span><span class="kw">,</span> <span class="dt">Regex_F</span>)</span>
<span id="cb23-8"><a href="#cb23-8"></a>  )<span class="kw">,</span> <span class="dt">Regex_List</span>)<span class="kw">,</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>  fold_union(<span class="dt">Regex_List</span><span class="kw">,</span> <span class="dt">Regex</span>)<span class="kw">.</span></span>
<span id="cb23-10"><a href="#cb23-10"></a></span>
<span id="cb23-11"><a href="#cb23-11"></a>fold_union(<span class="dt">Regex_List</span><span class="kw">,</span> <span class="dt">Union</span>) <span class="kw">:-</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>  foldl([<span class="dt">V0</span>, <span class="dt">E</span>, <span class="dt">V1</span>]<span class="al">&gt;&gt;</span>(<span class="dt">V1</span><span class="kw">=</span>regex_union(<span class="dt">V0</span><span class="kw">,</span> <span class="dt">E</span>))<span class="kw">,</span> <span class="dt">Regex_List</span><span class="kw">,</span> regex_null<span class="kw">,</span> <span class="dt">Union</span>)<span class="kw">.</span></span></code></pre></div>
<h1 id="simplifying-regular-expressions">Simplifying Regular Expressions</h1>
<p>The intermediate regular expression generated as part of Kleene’s algorithm are are extremely redundant and can be simplified significantly. This not only provides cleaner output; it also reduces the size of the table used to memoize the computation which keeps memory usage reasonable.</p>
<div class="sourceCode" id="cb24" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb24-1"><a href="#cb24-1"></a>simpl_regex(regex_union(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">:-</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  simpl_regex(<span class="dt">B</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,!.</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>simpl_regex(regex_concat(<span class="dt">E</span><span class="kw">,</span><span class="dt">A</span>)<span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>  simpl_regex(<span class="dt">E</span><span class="kw">,</span> regex_empty)<span class="kw">,</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">,!.</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>simpl_regex(regex_concat(<span class="dt">A</span><span class="kw">,</span><span class="dt">E</span>)<span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>  simpl_regex(<span class="dt">E</span><span class="kw">,</span> regex_empty)<span class="kw">,</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>)<span class="kw">,!.</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>simpl_regex(regex_union(<span class="dt">A</span><span class="kw">,</span><span class="dt">N</span>)<span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>  simpl_regex(<span class="dt">N</span><span class="kw">,</span> regex_null)<span class="kw">,</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,!.</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>simpl_regex(regex_union(<span class="dt">N</span><span class="kw">,</span><span class="dt">A</span>)<span class="kw">,</span> <span class="dt">B</span>) <span class="kw">:-</span></span>
<span id="cb24-14"><a href="#cb24-14"></a>  simpl_regex(<span class="dt">N</span><span class="kw">,</span> regex_null)<span class="kw">,</span></span>
<span id="cb24-15"><a href="#cb24-15"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,!.</span></span>
<span id="cb24-16"><a href="#cb24-16"></a>simpl_regex(regex_concat(<span class="dt">_</span><span class="kw">,</span><span class="dt">N</span>)<span class="kw">,</span> regex_null) <span class="kw">:-</span></span>
<span id="cb24-17"><a href="#cb24-17"></a>  simpl_regex(<span class="dt">N</span><span class="kw">,</span> regex_null)<span class="kw">,!.</span></span>
<span id="cb24-18"><a href="#cb24-18"></a>simpl_regex(regex_concat(<span class="dt">N</span><span class="kw">,</span><span class="dt">_</span>)<span class="kw">,</span> regex_null) <span class="kw">:-</span></span>
<span id="cb24-19"><a href="#cb24-19"></a>  simpl_regex(<span class="dt">N</span><span class="kw">,</span> regex_null)<span class="kw">,!.</span></span>
<span id="cb24-20"><a href="#cb24-20"></a>simpl_regex(regex_kleene(<span class="dt">E</span>)<span class="kw">,</span> regex_empty) <span class="kw">:-</span></span>
<span id="cb24-21"><a href="#cb24-21"></a>  simpl_regex(<span class="dt">E</span><span class="kw">,</span> regex_empty)<span class="kw">,!.</span></span>
<span id="cb24-22"><a href="#cb24-22"></a>simpl_regex(regex_kleene(<span class="dt">N</span>)<span class="kw">,</span> regex_null) <span class="kw">:-</span></span>
<span id="cb24-23"><a href="#cb24-23"></a>  simpl_regex(<span class="dt">N</span><span class="kw">,</span> regex_null)<span class="kw">,!.</span></span>
<span id="cb24-24"><a href="#cb24-24"></a>simpl_regex(regex_kleene(<span class="dt">K</span>)<span class="kw">,</span> regex_kleene(<span class="dt">L</span>)) <span class="kw">:-</span></span>
<span id="cb24-25"><a href="#cb24-25"></a>  simpl_regex(<span class="dt">K</span><span class="kw">,</span> <span class="dt">L</span>)<span class="kw">.</span></span>
<span id="cb24-26"><a href="#cb24-26"></a>simpl_regex(regex_concat(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,</span> regex_concat(<span class="dt">C</span><span class="kw">,</span><span class="dt">D</span>)) <span class="kw">:-</span></span>
<span id="cb24-27"><a href="#cb24-27"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span><span class="dt">C</span>)<span class="kw">,</span></span>
<span id="cb24-28"><a href="#cb24-28"></a>  simpl_regex(<span class="dt">B</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span></span>
<span id="cb24-29"><a href="#cb24-29"></a>simpl_regex(regex_union(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,</span> regex_union(<span class="dt">C</span><span class="kw">,</span><span class="dt">D</span>)) <span class="kw">:-</span></span>
<span id="cb24-30"><a href="#cb24-30"></a>  simpl_regex(<span class="dt">A</span><span class="kw">,</span><span class="dt">C</span>)<span class="kw">,</span></span>
<span id="cb24-31"><a href="#cb24-31"></a>  simpl_regex(<span class="dt">B</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span></span>
<span id="cb24-32"><a href="#cb24-32"></a>simpl_regex(regex_null<span class="kw">,</span> regex_null)<span class="kw">.</span></span>
<span id="cb24-33"><a href="#cb24-33"></a>simpl_regex(regex_empty<span class="kw">,</span> regex_empty)<span class="kw">.</span></span>
<span id="cb24-34"><a href="#cb24-34"></a>simpl_regex(regex_char(<span class="dt">C</span>)<span class="kw">,</span> regex_char(<span class="dt">C</span>))<span class="kw">.</span></span></code></pre></div>
<h1 id="printing-regular-expressions">Printing Regular Expressions</h1>
<p>This operation is essentially the inverse of parsing. I would like to be able to use the same predicate as used for parsing, but have not been able to get it working yet. For the time being, we use a separate predicate. Also note that this predicate uses Kleene closure (<code>*</code>) instead of the non-zero quantifier (<code>+</code>) used when parsing.</p>
<div class="sourceCode" id="cb25" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb25-1"><a href="#cb25-1"></a>show_regex(regex_char(<span class="dv">0</span>)<span class="kw">,</span> <span class="st">`0`</span>)<span class="kw">.</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>show_regex(regex_char(<span class="dv">1</span>)<span class="kw">,</span> <span class="st">`1`</span>)<span class="kw">.</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>show_regex(regex_empty<span class="kw">,</span> <span class="st">`</span><span class="er">_</span><span class="st">`</span>)<span class="kw">.</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>show_regex(regex_null<span class="kw">,</span> <span class="st">`!`</span>)<span class="kw">.</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>show_regex(regex_union(<span class="dt">L</span><span class="kw">,</span><span class="dt">R</span>)<span class="kw">,</span> <span class="dt">S</span>) <span class="kw">:-</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>  show_regex(<span class="dt">L</span><span class="kw">,</span> <span class="dt">SL</span>)<span class="kw">,</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>  show_regex(<span class="dt">R</span><span class="kw">,</span> <span class="dt">SR</span>)<span class="kw">,</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>  append([<span class="dt">SL</span>, <span class="dt">SR</span>, <span class="st">`|`</span>]<span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>show_regex(regex_concat(<span class="dt">L</span><span class="kw">,</span><span class="dt">R</span>)<span class="kw">,</span> <span class="dt">S</span>) <span class="kw">:-</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>  show_regex(<span class="dt">L</span><span class="kw">,</span> <span class="dt">SL</span>)<span class="kw">,</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>  show_regex(<span class="dt">R</span><span class="kw">,</span> <span class="dt">SR</span>)<span class="kw">,</span></span>
<span id="cb25-12"><a href="#cb25-12"></a>  append([<span class="dt">SL</span>, <span class="dt">SR</span>, <span class="st">`;`</span>]<span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>show_regex(regex_kleene(<span class="dt">K</span>)<span class="kw">,</span> <span class="dt">S</span>) <span class="kw">:-</span></span>
<span id="cb25-14"><a href="#cb25-14"></a>  show_regex(<span class="dt">K</span><span class="kw">,</span> <span class="dt">SK</span>)<span class="kw">,</span></span>
<span id="cb25-15"><a href="#cb25-15"></a>  append(<span class="dt">SK</span><span class="kw">,</span> <span class="st">`*`</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></span></code></pre></div>
<h1 id="appendix-graphiz-output">Appendix: Graphiz Output</h1>
<div class="sourceCode" id="cb26" data-file="regex.pl"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb26-1"><a href="#cb26-1"></a>term_codes(<span class="dt">T</span><span class="kw">,</span> <span class="dt">C</span>) <span class="kw">:-</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>  term_string(<span class="dt">T</span><span class="kw">,</span> <span class="dt">TS</span>)<span class="kw">,</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>  string_codes(<span class="dt">TS</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a>graphviz_delta(<span class="dt">F</span><span class="fu">-</span><span class="dt">D</span><span class="fu">-</span><span class="dt">T</span><span class="kw">,</span> <span class="dt">G</span>) <span class="kw">:-</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>  term_codes(<span class="dt">F</span><span class="kw">,</span> <span class="dt">FC</span>)<span class="kw">,</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>  term_codes(<span class="dt">T</span><span class="kw">,</span> <span class="dt">TC</span>)<span class="kw">,</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>  term_codes(<span class="dt">D</span><span class="kw">,</span> <span class="dt">DC</span>)<span class="kw">,</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>  append([<span class="st">`&quot;`</span>,<span class="dt">FC</span>, <span class="st">`&quot;</span><span class="al"> </span><span class="st">-&gt;</span><span class="al"> </span><span class="st">&quot;`</span>, <span class="dt">TC</span>, <span class="st">`&quot;</span><span class="al"> </span><span class="st">[</span><span class="al"> </span><span class="er">label</span><span class="st">=&quot;`</span>,<span class="dt">DC</span>,<span class="st">`&quot;];</span><span class="ch">\n</span><span class="st">`</span>]<span class="kw">,</span> <span class="dt">G</span>)<span class="kw">.</span></span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a>graphviz_finals(<span class="dt">F</span><span class="kw">,</span> <span class="dt">FS</span>) <span class="kw">:-</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>  (is_list(<span class="dt">F</span>)<span class="kw">,</span> <span class="kw">!,</span> <span class="dt">FL</span> <span class="kw">=</span> <span class="dt">F</span><span class="kw">;</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>   <span class="dt">FL</span> <span class="kw">=</span> [<span class="dt">F</span>])<span class="kw">,</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>   maplist(graphviz_final<span class="kw">,</span> <span class="dt">FL</span><span class="kw">,</span> <span class="dt">FSS</span>)<span class="kw">,</span> append(<span class="dt">FSS</span><span class="kw">,</span> <span class="dt">FS</span>)<span class="kw">.</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a>graphviz_final(<span class="dt">F</span><span class="kw">,</span> <span class="dt">FS</span>) <span class="kw">:-</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>  term_codes(<span class="dt">F</span><span class="kw">,</span> <span class="dt">FC</span>)<span class="kw">,</span></span>
<span id="cb26-18"><a href="#cb26-18"></a>  append([<span class="st">`&quot;`</span>, <span class="dt">FC</span>, <span class="st">`&quot;</span><span class="al"> </span><span class="st">[</span><span class="er">shape</span><span class="st">=</span><span class="er">doublecircle</span><span class="st">];</span><span class="ch">\n</span><span class="st">`</span>]<span class="kw">,</span> <span class="dt">FS</span>)<span class="kw">.</span></span>
<span id="cb26-19"><a href="#cb26-19"></a></span>
<span id="cb26-20"><a href="#cb26-20"></a>graphviz_initial(<span class="dt">I</span><span class="kw">,</span> <span class="dt">IS</span>) <span class="kw">:-</span></span>
<span id="cb26-21"><a href="#cb26-21"></a>  term_codes(<span class="dt">I</span><span class="kw">,</span> <span class="dt">IC</span>)<span class="kw">,</span></span>
<span id="cb26-22"><a href="#cb26-22"></a>  append([<span class="st">`</span><span class="er">initial</span><span class="al"> </span><span class="st">[</span><span class="er">label</span><span class="st">=&quot;&quot;,</span><span class="al"> </span><span class="er">shape</span><span class="st">=</span><span class="er">none</span><span class="st">,</span><span class="al"> </span><span class="er">height</span><span class="st">=.0,</span><span class="er">width</span><span class="st">=.0];</span><span class="ch">\n</span><span class="st">`</span>,</span>
<span id="cb26-23"><a href="#cb26-23"></a>         <span class="st">`</span><span class="er">initial</span><span class="al"> </span><span class="st">-&gt;</span><span class="al"> </span><span class="st">&quot;`</span>, <span class="dt">IC</span>, <span class="st">`&quot;;`</span>]<span class="kw">,</span> <span class="dt">IS</span>)<span class="kw">.</span></span>
<span id="cb26-24"><a href="#cb26-24"></a></span>
<span id="cb26-25"><a href="#cb26-25"></a>graphviz(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">G</span>) <span class="kw">:-</span></span>
<span id="cb26-26"><a href="#cb26-26"></a>  maplist(graphviz_delta<span class="kw">,</span> <span class="dt">NFA</span><span class="al">.</span>delta<span class="kw">,</span> <span class="dt">GS</span>)<span class="kw">,</span></span>
<span id="cb26-27"><a href="#cb26-27"></a>  graphviz_finals(<span class="dt">NFA</span><span class="al">.</span>final<span class="kw">,</span> <span class="dt">FS</span>)<span class="kw">,</span></span>
<span id="cb26-28"><a href="#cb26-28"></a>  graphviz_initial(<span class="dt">NFA</span><span class="al">.</span>initial<span class="kw">,</span> <span class="dt">IS</span>)<span class="kw">,</span></span>
<span id="cb26-29"><a href="#cb26-29"></a>  append([[<span class="st">`</span><span class="er">digraph</span><span class="al"> </span><span class="st">{</span><span class="ch">\n</span><span class="st">`</span>, <span class="dt">FS</span>, <span class="st">`</span><span class="ch">\n</span><span class="st">`</span>, <span class="dt">IS</span>], <span class="dt">GS</span>, [<span class="st">`}</span><span class="ch">\n</span><span class="st">`</span>]]<span class="kw">,</span> <span class="dt">GSS</span>)<span class="kw">,</span></span>
<span id="cb26-30"><a href="#cb26-30"></a>  append(<span class="dt">GSS</span><span class="kw">,</span> <span class="dt">G</span>)<span class="kw">.</span></span>
<span id="cb26-31"><a href="#cb26-31"></a></span>
<span id="cb26-32"><a href="#cb26-32"></a>graphviz_file(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">Out</span>) <span class="kw">:-</span></span>
<span id="cb26-33"><a href="#cb26-33"></a>  graphviz(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">G</span>)<span class="kw">,</span></span>
<span id="cb26-34"><a href="#cb26-34"></a>  <span class="fu">open</span>(<span class="dt">Out</span><span class="kw">,</span> <span class="fu">write</span><span class="kw">,</span> <span class="dt">Stream</span>)<span class="kw">,</span></span>
<span id="cb26-35"><a href="#cb26-35"></a>  string_codes(<span class="dt">GS</span><span class="kw">,</span> <span class="dt">G</span>)<span class="kw">,</span></span>
<span id="cb26-36"><a href="#cb26-36"></a>  <span class="fu">write</span>(<span class="dt">Stream</span><span class="kw">,</span> <span class="dt">GS</span>)<span class="kw">,</span></span>
<span id="cb26-37"><a href="#cb26-37"></a>  <span class="fu">close</span>(<span class="dt">Stream</span>)<span class="kw">.</span></span>
<span id="cb26-38"><a href="#cb26-38"></a></span>
<span id="cb26-39"><a href="#cb26-39"></a><span class="kw">:-</span> use_module(library(process))<span class="kw">.</span></span>
<span id="cb26-40"><a href="#cb26-40"></a></span>
<span id="cb26-41"><a href="#cb26-41"></a>graphviz_display(<span class="dt">NFA</span>) <span class="kw">:-</span></span>
<span id="cb26-42"><a href="#cb26-42"></a>  graphviz(<span class="dt">NFA</span><span class="kw">,</span> <span class="dt">G</span>)<span class="kw">,</span></span>
<span id="cb26-43"><a href="#cb26-43"></a>  string_codes(<span class="dt">GS</span><span class="kw">,</span> <span class="dt">G</span>)<span class="kw">,</span></span>
<span id="cb26-44"><a href="#cb26-44"></a></span>
<span id="cb26-45"><a href="#cb26-45"></a>  tmp_file_stream(text<span class="kw">,</span> <span class="dt">Dot_File</span><span class="kw">,</span> <span class="dt">Dot_Stream</span>)<span class="kw">,</span></span>
<span id="cb26-46"><a href="#cb26-46"></a>  <span class="fu">write</span>(<span class="dt">Dot_Stream</span><span class="kw">,</span> <span class="dt">GS</span>)<span class="kw">,</span></span>
<span id="cb26-47"><a href="#cb26-47"></a>  <span class="fu">close</span>(<span class="dt">Dot_Stream</span>)<span class="kw">,</span></span>
<span id="cb26-48"><a href="#cb26-48"></a></span>
<span id="cb26-49"><a href="#cb26-49"></a>  tmp_file_stream(binary<span class="kw">,</span> <span class="dt">PNG_File</span><span class="kw">,</span> <span class="dt">PNG_Stream</span>)<span class="kw">,</span></span>
<span id="cb26-50"><a href="#cb26-50"></a>  <span class="fu">close</span>(<span class="dt">PNG_Stream</span>)<span class="kw">,</span></span>
<span id="cb26-51"><a href="#cb26-51"></a>  process_create(path(dot)<span class="kw">,</span> [<span class="st">&#39;-</span><span class="er">Tpng</span><span class="st">&#39;</span>, <span class="st">&#39;-</span><span class="er">o</span><span class="st">&#39;</span>, <span class="dt">PNG_File</span>, <span class="dt">Dot_File</span>]<span class="kw">,</span> [])<span class="kw">,</span></span>
<span id="cb26-52"><a href="#cb26-52"></a></span>
<span id="cb26-53"><a href="#cb26-53"></a>  process_create(path(display)<span class="kw">,</span> [<span class="dt">PNG_File</span>]<span class="kw">,</span> [])<span class="kw">,</span></span>
<span id="cb26-54"><a href="#cb26-54"></a></span>
<span id="cb26-55"><a href="#cb26-55"></a>  delete_file(<span class="dt">Dot_File</span>)<span class="kw">,</span></span>
<span id="cb26-56"><a href="#cb26-56"></a>  delete_file(<span class="dt">PNG_File</span>)<span class="kw">.</span></span></code></pre></div>
</body>
</html>
